# RT-Thread 学习笔记

- 程序**内存分布**：

  - Code：代码段，存放程序的代码部分；
  - RO-data：只读数据段，存放程序中定义的常量；
  - RW-data：读写数据段，存放初始化为非 0 值的全局变量；
  - ZI-data：0 数据段，存放未初始化的全局变量及初始化为 0 的变量；

  stm32 上电默认从 **Flash** 启动，启动后将 RW 段中的 RW-data（初始化的全局变量）搬运到 **RAM** 中，另外根据编译器给出的 ZI 地址和大小分配出 ZI 段，并将这块 RAM 区域清零，剩余未使用的 RAM 空间做动态内存堆。

- 数值越小的优先级越高，0 为最高优先级。

- 时间片仅对**优先级相同**的**就绪态**线程有效。

- **空闲线程**完成最后的线程删除动作。

- 用户提供的栈首地址需做系统对齐。

- 线程本身不应调用 `rt_thread_detach()` **脱离线程本身**。

-  `rt_thread_suspend()` 只能使用来挂起当前线程（即**自己挂起自己**），而且在挂起线程自己后，需要立刻调用 `rt_schedule()` 函数进行手动的线程上下文切换。

- **空闲线程**是一个线程状态**永远为就绪态**的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，由于 **malloc、free** 等内存相关的函数内部使用了信号量作为临界区保护，因此在钩子函数内部也不允许调用此类函数！（基本上不允许调用系统 API)

- 

